# Technical descisions

All the types (`Pitch`, `Note`, `Chord`, etc.) should immutable. Any action that should return a modified instance of a type should return a new instance instead.

# Types

- [`Step`](#Step): Represents the steps A, B, C, D, E, F, G.
- [`Pitch`](#Pitch): Represents the pitches A, B, C, D, E, F, G, and their altered versions.
- [`Note`](#Note): Represents a note (pitch + octave).
- [`PlayedNote`](#PlayedNote): Represents a note that's being played for a certain amount of time.
- [`Duration`](#Duration): Represents an amount of time.

## Pitch

A definition of a musical pitch. This doesn't contain the Octave, it should purely represent the pitches A, B, C, D, E, F, G, and their altered versions.

We could also consider using an enum for Alter. I'm fine with either way.

## Step

```csharp
public enum Step : byte
{
    C = 0,
    D = 2,
    E = 4,
    F = 5,
    G = 7,
    A = 9,
    B = 11,
}
```

```csharp
public class Pitch
{
    public Step Step { get; }
    public int Alter { get; }
}
```

## Note

A Pitch plus Octave. Represent a pitch in an absolute way.

```csharp
public class Note
{
    public Pitch Pitch { get; }
    public int Octave { get; }
}
```
```

## ChordFormula

A formula for a chord. Contains the pitches to construct a certain chord.

```csharp
public class ChordFormula
{
    public IReadOnlyList<Pitch> Pitches { get; }
    public Pitch Root { get; }
    public Pitch Lead { get; }
    public int Inversion { get; } // TODO: does this make sense?
    public string Quality { get; } // TODO: how to represent chord quality?
}
```

## Chord

A concrete chord, with notes in specific octaves.

```csharp
public class Chord
{
    public IReadOnlyList<Note> Notes { get; }
    public Note Root { get; }
    public Note Lead { get; }
    public int Inversion { get; } // TODO: does this make sense?
    public string Quality { get; } // TODO: how to represent chord quality?
}
```

## ScaleFormula

TODO
